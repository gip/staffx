---
kind: Document
hash: sha256:440d3a7e340176accad589ee59162fe8f0c487fe0ac5d847fc691d4c2c2204c0
title: Deployment Topology and Environments
language: en
---

This document describes deployment surfaces and runtime topology by environment.

Local development topology:
- API runs as a Node.js Fastify process on local host with CORS enabled for client origins.
- Web client runs via Vite dev server and calls API under the configured base URL.
- Desktop app runs Electron main/preload/renderer with secure context bridge and token-backed API calls.
- PostgreSQL runs locally or in a reachable development environment.

Hosted topology assumptions:
- API can be deployed as a long-lived process or containerized service with stable outbound access to Auth0, Google, and Notion.
- Web client can be statically hosted with environment-specific API base URL.
- Desktop ships as a packaged application and continues to call deployed API plus external auth/integration providers.

Environment segmentation:
- Development, staging, and production should isolate credentials, callback URLs, and database instances.
- Event streams and assistant-run worker identities should be separated by environment.
- Integration OAuth credentials and token stores must never be shared across environments.

Release and rollback:
- Apply migrations before rolling forward API versions that depend on new schema.
- Roll back API only to versions compatible with current schema or provide migration rollback plan.
- Validate health, authentication, projects, threads, events, and assistant-run lifecycle after each release.

Capacity and reliability considerations:
- Size API and DB for thread/event write volume and polling/SSE client concurrency.
- Monitor long-running assistant completion operations and OpenShip reconciliation latency.
- Ensure log retention captures request IDs and event IDs needed for incident reconstruction.
