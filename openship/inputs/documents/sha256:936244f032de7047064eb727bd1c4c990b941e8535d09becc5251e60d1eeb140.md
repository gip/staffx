---
kind: Document
hash: sha256:936244f032de7047064eb727bd1c4c990b941e8535d09becc5251e60d1eeb140
title: Connectivity and Dependency Model
language: en
---

Connectivity model and dependency rationale across the active runtime graph.

Client to API paths:
- Web client and desktop renderer communicate with API over HTTPS using bearer-authenticated JSON endpoints.
- Desktop main process may also communicate with API and coordinates secure local behaviors through IPC to renderer.

Identity and OAuth paths:
- Web and desktop initiate identity flows through Auth0.
- Auth0 federates to Google OAuth for social login paths.
- API performs provider OAuth callback exchanges and status/disconnect operations.

Integration API paths:
- API calls Google Docs and Notion APIs using stored provider tokens.
- Failures in provider paths are isolated from core project/thread persistence and surfaced as integration state issues.

Dataflow and dependency paths:
- API and PostgreSQL communicate over pgwire with transactional guarantees for project/thread/system changes.
- Web and desktop renderer depend on shared UI library components.
- API and desktop main depend on shared agent runtime library for assistant-related orchestration and OpenShip diff behavior.

Rebuild checks:
1. Every declared runtime/dataflow edge has resolvable endpoint configuration.
2. Authentication and authorization are applied consistently at API ingress.
3. Dependency edges to shared libraries are satisfied at build and runtime.
4. Protocol/layer7 metadata in edges remains aligned with actual runtime behavior.
