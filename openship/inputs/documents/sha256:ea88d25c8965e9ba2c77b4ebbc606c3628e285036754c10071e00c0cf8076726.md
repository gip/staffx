---
kind: Document
hash: sha256:ea88d25c8965e9ba2c77b4ebbc606c3628e285036754c10071e00c0cf8076726
title: Eventing and Real-Time Delivery Model
language: en
---

Eventing model for polling and server-sent events delivery.

Event generation:
- API writes domain events for matrix changes, assistant run lifecycle transitions, and related thread/session milestones.
- Events are stored in a durable events table and exposed through cursor-based polling and SSE streaming routes.

Polling contract:
- Clients call the events endpoint with optional cursor/since parameters.
- Responses include ordered events and next-cursor metadata for incremental consumption.
- Consumers should checkpoint cursor after durable handling to avoid replay gaps.

SSE contract:
- Stream endpoint supports resume via Last-Event-ID and since semantics.
- Stream emits event id/type/data frames and heartbeat comments to keep connections alive.
- Clients must reconnect on disconnect, resume from last acknowledged event id, and deduplicate by event id.

Ordering and consistency:
- Ordering is authoritative by persisted event sequence/time semantics, not client receipt order.
- UI reconciliation logic should be idempotent and tolerant to repeated events.
- Polling and SSE should produce equivalent domain outcomes when replayed from same cursor.

Rebuild and validation guidance:
1. Verify both polling and SSE paths produce consistent updates for thread and assistant-run scenarios.
2. Verify reconnect behavior after network interruptions and process restarts.
3. Verify high-volume event bursts do not violate ordering or drop events.
4. Verify cursor parsing/encoding compatibility between client and server.
